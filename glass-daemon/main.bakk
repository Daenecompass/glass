// Copyright 2015 Daniel Theophanes.
// Use of this source code is governed by a zlib-style
// license that can be found in the LICENSE file.package service

// Simple service that only works by printing a log message every few seconds.
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/signal"
	"time"

	"github.com/timeglass/glass/_vendor/github.com/hashicorp/errwrap"
	"github.com/timeglass/glass/_vendor/github.com/kardianos/service"

	"github.com/timeglass/glass/model"
	"github.com/timeglass/snow/monitor"
)

var Version = "0.0.0"
var Build = "gobuild"

var logger service.Logger

// Service setup.
//   Define service config.
//   Create the service.
//   Setup the logger.
//   Handle service controls (optional).
//   Run the service.
func main() {
	svcFlag := flag.String("service", "", "Control the system service.")
	flag.Parse()
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(errwrap.Wrapf("Failed to fetch current working dir: {{err}}", err))
	}

	svcConfig := &service.Config{
		Name:        "Glass2",
		DisplayName: "Timeglass2",
		Description: "This is an example Go service that outputs log messages.",
	}

	timer := NewTimer(time.Second, 4*time.Second)
	svr, err := NewServer(":0", timer)
	if err != nil {
		log.Fatal(err)
	}

	monitor, err := monitor.New(dir, monitor.Recursive, time.Millisecond*50)
	if err != nil {
		log.Fatal(errwrap.Wrapf(fmt.Sprintf("Failed to create monitor for directory '%s': {{err}}", dir), err))
	}

	go func() {
		for err := range monitor.Errors() {
			log.Printf("Monitor Error: %s", err)
		}
	}()

	timer.Wakeup, err = monitor.Start()
	if err != nil {
		log.Fatal(errwrap.Wrapf(fmt.Sprintf("Failed to start monitor for directory '%s': {{err}}"), err))
	}

	sig := make(chan os.Signal)
	signal.Notify(sig, os.Interrupt)
	go func() {
		<-sig
		svr.Stop(nil)
	}()

	s, err := service.New(svr, svcConfig)
	if err != nil {
		log.Fatal(err)
	}
	errs := make(chan error, 5)
	logger, err = s.Logger(errs)
	if err != nil {
		log.Fatal(err)
	}

	go func() {
		for {
			err := <-errs
			if err != nil {
				log.Print(err)
			}
		}
	}()

	if len(*svcFlag) != 0 {
		err := service.Control(s, *svcFlag)
		if err != nil {
			log.Printf("Valid actions: %q\n", service.ControlAction)
			log.Fatal(err)
		}
		return
	}

	// model

	m := model.New(dir)
	info, err := m.ReadDaemonInfo()
	if err != nil {
		log.Fatal(errwrap.Wrapf("Failed read Daemon info: {{err}}", err))
	}

	if info.Addr != "" {
		log.Printf("It appears another Daemon is already running or a previous instance didn't shutdown properly, use -force to force start.")
	}

	err = s.Run()
	if err != nil {
		log.Print(err)
	}

	info = model.NewDeamon(dir, svr.Addr())
	err = m.UpsertDaemonInfo(info)
	if err != nil {
		log.Fatal(errwrap.Wrapf("Failed write Daemon info: {{err}}", err))
	}

	//actually run

	// shutdown
	log.Printf("Writing information to database...")
	info.Addr = ""
	err = m.UpsertDaemonInfo(info)
	if err != nil {
		log.Fatal(errwrap.Wrapf("Failed write Daemon info: {{err}}", err))
	}

	log.Printf("Done")

}
